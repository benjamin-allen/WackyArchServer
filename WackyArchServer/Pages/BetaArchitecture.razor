@page "/beta"

@using WackyArchServer.Model

<div id="beta-arch-container">
    <div id="beta-description"></div>
    <div id="beta-arch-emulator-container">
        <FilledPort Port="UserInputPort"></FilledPort>
        <CodeBox Disabled=true @ref="codeBox"></CodeBox>
        <CPUInfo Cpu="Cpu" ShowLoadButton="false" ResetButtonPressed="Reset" StepButtonPressed="Step" RunButtonPressed="Run" SubmitButtonPressed="Submit"></CPUInfo>
        <StackView Stack="Cpu.Stack"></StackView>
        <MemoryView Cpu="Cpu" Memory="Memory" OnMemoryChanged="MemoryChanged"></MemoryView>
    </div>
    <div id="beta-arch-input">
        <table>
            @for (int i = 0; i < PreparedInput.Count; i++)
            {
                var j = i;
                <tr>
                    <td>@i</td>
                    <td>@PreparedInput[j]</td>
                    <td><button @onclick="(async () => await Add(j))">+</button></td>
                    <td><button @onclick="(async () => await Delete(j))">-</button></td>
                </tr>
            }
            <tr>
                <td></td>
                <td></td>
                <td><button @onclick="(async () => await Add(PreparedInput.Count))">+</button></td>
                <td></td>
            </tr>
        </table>
    </div>
</div>

@code {
    private StackCPU Cpu { get; set; } = new();
    private Memory Memory { get; set; } = new(2);
    private List<WackyArch.Components.FilledPort> InputPorts { get; set; } = new();
    private List<ICyclable> cyclables = new();

    private WackyArch.Components.FilledPort UserInputPort { get; set; } = new(new List<Word>(), new Pipe(), "KP");
    private List<int> PreparedInput { get; set; } = new();

    private WackyArchServer.UIComponents.CodeBox codeBox;

    protected async override Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        Memory = new Memory(256);
        var dataPort = new Port(Memory.Data, "DATA");
        var addrPort = new Port(Memory.Address, "ADDR");
        UserInputPort = new WackyArch.Components.FilledPort(PreparedInput.Select(x => new Word { Value = x }).ToList(), new Pipe(), "KP");
        Cpu = new StackCPU(new Port[] { dataPort, addrPort, UserInputPort });
        cyclables = new List<ICyclable> { Cpu, Memory, UserInputPort };
    }

    private async Task MemoryChanged()
    {
        // Get binary and disassemble it
        var binary = Memory.Words;
        var programText = Disassembler.Disassemble(Cpu, binary.ToList(), out var pcLineMap);
        Cpu.PcLineMap = pcLineMap;
        Cpu.ProgramBinary = binary.ToList();

        // Set the codebox text to the new code.
        await codeBox.SetText(programText);
        await codeBox.SetLinePointer(0, false);
    }

    private async Task Add(int i)
    {
        PreparedInput.Insert(i, i);
    }

    private async Task Delete(int i)
    {
        PreparedInput.RemoveAt(i);
    }

    private async Task Reset()
    {
        cyclables.ForEach(c => c.Reset());

        // Load memory with program

        UserInputPort = new WackyArch.Components.FilledPort(PreparedInput.Select(x => new Word { Value = x }).ToList(), new Pipe(), "INPUT");
        var dataPort = new Port(Memory.Data, "DATA");
        var addrPort = new Port(Memory.Address, "ADDR");
        Cpu = new StackCPU(new Port[] { dataPort, addrPort, UserInputPort });
        cyclables = new List<ICyclable> { Cpu, Memory, UserInputPort };

        codeBox.SetInfoMessage("System Reset");
        await MemoryChanged();
        StateHasChanged();
    }

    private async Task Step()
    {
        try
        {
            codeBox.SetInfoMessage("");
            cyclables.ForEach(c => c.Cycle());
            if (Cpu.IsHalted)
            {
                codeBox.SetInfoMessage("Program Complete");
            }
            else
            {
                codeBox.SetInfoMessage("Waiting for output...");
            }
        }
        catch (ComponentException cex)
        {
            codeBox.SetInfoMessage(cex.ShortMessage);
            Cpu.IsErrored = true;
        }
        catch (Interrupt i)
        {
            switch (i.InterruptType)
            {
                case InterruptType.UNLOCK:
                    codeBox.SetInfoMessage("== Unlocked =="); break;
                case InterruptType.HALT:
                    codeBox.SetInfoMessage("== Halted =="); break;
            }
        }
        finally
        {
            var isInLineMap = Cpu.PcLineMap.TryGetValue(Cpu.GetPCValue(), out int currentLine);
            await codeBox.SetLinePointer(isInLineMap ? currentLine+1 : 0, Cpu.IsErrored);
            StateHasChanged();
        }
    }

    private async Task Run(object state)
    {
        do
        {
            await Step();
            StateHasChanged();
            await Task.Delay(1);
        } while (Cpu.IsHalted == false && Cpu.IsErrored == false);
    }

    private async Task Submit()
    {
        codeBox.SetInfoMessage("Submitted");
        StateHasChanged();

        // Todo: gather the input from the user's input manager and sent it to the service
    }
}